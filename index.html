<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>理科実験シミュレーター</title>
    <style>
        :root {
            --border-color: #ccc;
            --background-color: #f4f4f9;
            --workspace-bg: #fff;
            --selected-outline-color: #007bff;
        }
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            background-color: var(--background-color);
        }
        .title-bar {
            padding: 10px;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            background: #e9ecef;
        }
        .title-bar h1 {
            margin: 0;
            font-size: 1.5em;
        }
        #app-container {
            display: flex;
            flex-grow: 1;
            height: 0;
        }
        #palette {
            width: 250px;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }
        .tabs {
            display: flex;
        }
        .tab {
            flex: 1;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            background-color: #eee;
        }
        .tab.active {
            background-color: var(--workspace-bg);
            border-bottom-color: transparent;
        }
        .item-list {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
        }
        .item {
            display: flex;
            align-items: center;
            padding: 5px;
            cursor: grab;
            margin-bottom: 10px;
            border: 1px solid transparent;
            border-radius: 4px;
        }
        .item.clickable {
            cursor: pointer;
        }
        
        .item:hover {
            background-color: #e9e9e9;
        }
        .item img, .item svg {
            width: 40px;
            height: 40px;
            margin-right: 10px;
        }
        .item span {
            font-size: 14px;
        }
        #main-area {
            flex-grow: 1;
            display: flex;
        }
        #workspace {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            background-color: var(--workspace-bg);
        }
        .workspace-item {
            position: absolute;
            cursor: move;
        }
        .workspace-item.selected {
            outline: 2px solid var(--selected-outline-color);
            outline-offset: 2px;
        }
        .workspace-item svg {
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #controls-log {
            width: 300px;
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            padding: 10px;
        }
        #controls h3, #log h3 {
            margin-top: 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        .control-group input {
            width: 100%;
        }
        #log {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        #log-entries {
            flex-grow: 1;
            overflow-y: auto;
            font-size: 12px;
            background-color: #fdfdfd;
            border: 1px solid #eee;
            padding: 5px;
        }
        #log-entries p {
            margin: 0 0 5px;
        }
        .hidden {
            display: none;
        }
        button {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            cursor: pointer;
        }
        #delete-btn {
            background-color: #dc3545;
            color: white;
            border: none;
        }
        #reset-btn {
            background-color: #6c757d;
            color: white;
            border: none;
        }

        /* Modal Styles */
        #modal-backdrop, #text-modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #amount-modal, #text-modal {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            width: 300px;
        }
        #amount-modal h3, #text-modal h3 {
            margin-top: 0;
        }
        #amount-modal .input-group, #text-modal .input-group {
            display: flex;
            margin-bottom: 15px;
        }
        #amount-modal input[type="number"], #text-modal input[type="text"] {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        #amount-modal select {
            padding: 8px;
            border: 1px solid #ccc;
            border-left: none;
            border-radius: 0 4px 4px 0;
        }
        #amount-modal .buttons, #text-modal .buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        #amount-modal button, #text-modal button {
            width: auto;
            padding: 8px 20px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        #modal-ok, #text-modal-ok {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }

        /* Drawing Styles */
        #drawing-surface {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Initially, let clicks pass through */
            z-index: 10; /* Make sure it's on top of items */
        }
        #workspace.drawing-mode, #workspace.text-mode {
            cursor: crosshair;
        }
        #workspace.drawing-mode #drawing-surface, #workspace.text-mode #drawing-surface {
            pointer-events: all; /* Capture clicks when in drawing mode */
        }
        .drawn-line {
            stroke: #555;
            stroke-width: 6;
            stroke-linecap: round;
            fill: none;
            pointer-events: stroke; /* Allow clicking on the line itself */
            cursor: pointer;
        }
        .drawn-line.selected {
            stroke: var(--selected-outline-color);
        }
        .text-item {
            padding: 5px;
            min-width: 20px;
        }
    </style>
</head>
<body>
    <!-- Global SVG definitions -->
    <svg width="0" height="0" style="position:absolute;z-index:-1;">
      <defs>
        <pattern id="powder" patternUnits="userSpaceOnUse" width="5" height="5">
          <circle cx="2.5" cy="2.5" r="1" fill="#a9a9a9"></circle>
        </pattern>
      </defs>
    </svg>

    <div class="title-bar">
        <h1>理科実験シミュレーター</h1>
    </div>

    <div id="app-container">
        <div id="palette">
            <div class="tabs">
                <div class="tab active" data-tab="kigu">器具</div>
                <div class="tab" data-tab="kotai">固体</div>
                <div class="tab" data-tab="ekitai">液体</div>
                <div class="tab" data-tab="byoga">描画</div>
            </div>
            <div id="kigu-list" class="item-list"></div>
            <div id="kotai-list" class="item-list hidden"></div>
            <div id="ekitai-list" class="item-list hidden"></div>
            <div id="byoga-list" class="item-list hidden"></div>
        </div>

        <div id="main-area">
            <div id="workspace">
                <svg id="drawing-surface"></svg>
            </div>
            <div id="controls-log">
                <div id="controls">
                    <h3>操作</h3>
                    <div id="selection-controls" class="hidden">
                        <div class="control-group">
                            <label for="size-input">サイズ (<span id="size-value">100</span>%)</label>
                            <input type="range" id="size-input" min="20" max="180" value="100">
                        </div>
                        <div class="control-group">
                            <label for="angle-input">角度 (<span id="angle-value">0</span>°)</label>
                            <input type="range" id="angle-input" min="-180" max="180" value="0">
                        </div>
                        <button id="delete-btn">選択中のアイテムを削除</button>
                    </div>
                    <p id="no-selection">アイテムを選択してください</p>
                    <button id="reset-btn">すべてリセット</button>
                </div>
                <div id="log">
                    <h3>ログ</h3>
                    <div id="log-entries"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Amount Input Modal -->
    <div id="modal-backdrop" style="display: none;">
        <div id="amount-modal">
            <h3 id="modal-title"></h3>
            <div class="input-group">
                <input type="number" id="modal-amount" value="10" min="0">
                <select id="modal-unit"></select>
            </div>
            <div class="buttons">
                <button id="modal-cancel">キャンセル</button>
                <button id="modal-ok">OK</button>
            </div>
        </div>
    </div>

    <!-- Text Input Modal -->
    <div id="text-modal-backdrop" style="display: none;">
        <div id="text-modal">
            <h3>テキストを入力</h3>
            <div class="input-group">
                <input type="text" id="text-modal-input" value="ラベル">
            </div>
            <div class="buttons">
                <button id="text-modal-cancel">キャンセル</button>
                <button id="text-modal-ok">OK</button>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', async () => {
        const svgCache = {};
        const kiguNameMap = {
            'alcohol-lamp': 'アルコールランプ', 'beaker': 'ビーカー', 'conical_beaker': '三角フラスコ',
            'conical_beaker_tall': 'コニカルビーカー', 'evaporating_dish': '蒸発皿', 'flask': 'メスフラスコ',
            'funnel': 'ろうと', 'gas_jar': '集気びん', 'glass_lid': 'ガラスふた',
            'graduated_cylinder': 'メスシリンダー', 'stand': 'スタンド', 'test_tube': '試験管',
            'tripod': '三脚', 'whole_pipette': 'ホールピペット', 'wire_gauze': '金網', 'liebig_condenser': 'リービッヒ冷却器',
            'rubber-tube': 'ゴム管', 'text-tool': 'テキスト'
        };
        const containerNames = ['beaker', 'conical_beaker', 'conical_beaker_tall', 'flask', 'test_tube', 'graduated_cylinder', 'evaporating_dish'];
        const items = {
            kigu: Object.keys(kiguNameMap),
            kotai: ['NaOH', 'NaCl', 'NaHCO3', 'CaCO3'],
            ekitai: ['H₂O', 'HCl', 'H₂SO₄', 'HNO₃', 'CH₃COOH']
        };

        // --- UI & Item Generation ---
        const kiguList = document.getElementById('kigu-list');
        const kotaiList = document.getElementById('kotai-list');
        const ekitaiList = document.getElementById('ekitai-list');
        const byogaList = document.getElementById('byoga-list');
        const workspace = document.getElementById('workspace');
        const drawingSurface = document.getElementById('drawing-surface');
        const logEntries = document.getElementById('log-entries');
        const tabs = document.querySelectorAll('.tab');
        let selectedItem = null;
        let itemIdCounter = 0;

        // --- Modal Elements & Logic ---
        const modalBackdrop = document.getElementById('modal-backdrop');
        const modalTitle = document.getElementById('modal-title');
        const modalAmount = document.getElementById('modal-amount');
        const modalUnit = document.getElementById('modal-unit');
        const modalOk = document.getElementById('modal-ok');
        const modalCancel = document.getElementById('modal-cancel');
        let amountModalResolve = null;

        const textModalBackdrop = document.getElementById('text-modal-backdrop');
        const textModalInput = document.getElementById('text-modal-input');
        const textModalOk = document.getElementById('text-modal-ok');
        const textModalCancel = document.getElementById('text-modal-cancel');
        let textModalResolve = null;

        function showAmountModal(chemicalData) {
            modalTitle.textContent = `「${chemicalData.displayName}」を追加`;
            modalUnit.innerHTML = '';
            const units = chemicalData.type === 'ekitai' 
                ? { 'L': 'L', 'dL': 'dL', 'mL': 'mL' }
                : { 'kg': 'kg', 'g': 'g', 'mg': 'mg' };
            
            for (const [value, text] of Object.entries(units)) {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = text;
                modalUnit.appendChild(option);
            }
            modalUnit.value = chemicalData.type === 'ekitai' ? 'mL' : 'g';

            modalBackdrop.style.display = 'flex';
            modalAmount.focus();
            modalAmount.select();

            return new Promise(resolve => { amountModalResolve = resolve; });
        }
        
        function showTextModal() {
            textModalBackdrop.style.display = 'flex';
            textModalInput.focus();
            textModalInput.select();
            return new Promise(resolve => { textModalResolve = resolve; });
        }

        modalOk.addEventListener('click', () => {
            const amount = parseFloat(modalAmount.value);
            if (isNaN(amount) || amount <= 0) {
                alert('有効な数値を入力してください。');
                return;
            }
            modalBackdrop.style.display = 'none';
            if (amountModalResolve) amountModalResolve({ amount, unit: modalUnit.value });
        });

        modalCancel.addEventListener('click', () => {
            modalBackdrop.style.display = 'none';
            if (amountModalResolve) amountModalResolve(null);
        });

        textModalOk.addEventListener('click', () => {
            const text = textModalInput.value;
            if (!text) {
                alert('テキストを入力してください。');
                return;
            }
            textModalBackdrop.style.display = 'none';
            if (textModalResolve) textModalResolve(text);
        });

        textModalCancel.addEventListener('click', () => {
            textModalBackdrop.style.display = 'none';
            if (textModalResolve) textModalResolve(null);
        });


        // --- Asset Loading ---
        async function loadSvg(url) {
            if (svgCache[url]) return svgCache[url];
            const response = await fetch(url);
            const text = await response.text();
            svgCache[url] = text;
            return text;
        }

        // --- Substance & Visuals Logic ---
        async function onChemicalClick(e) {
            const clickedItemData = e.currentTarget.dataset;
            if (!selectedItem || !selectedItem.classList.contains('workspace-item')) {
                alert('先に対象の容器を選択してください。');
                return;
            }
            const targetData = selectedItem.dataset;
            if (targetData.type !== 'kigu' || !containerNames.includes(targetData.name)) {
                alert('液体や固体は容器にのみ追加できます。');
                return;
            }

            const result = await showAmountModal(clickedItemData);
            if (!result) return;

            const { amount, unit } = result;
            logAction(`「${targetData.displayName}」に「${clickedItemData.displayName}」を ${amount}${unit} 追加しました。`);
            
            // Access the shadowRoot to find the content path
            const contentPath = selectedItem.shadowRoot.querySelector('#content');
            if (!contentPath) {
                console.error('This container is not properly configured to hold content.');
                return;
            }

            const contentType = clickedItemData.type;
            // The 'powder' pattern ID is now also scoped to the shadow DOM.
            contentPath.style.fill = contentType === 'ekitai' ? 'rgba(173, 216, 230, 0.7)' : 'url(#powder)';
            contentPath.style.display = 'block';
        }

        function createPaletteItem(list, data) {
            const item = document.createElement('div');
            item.className = 'item';
            item.dataset.type = data.type;
            item.dataset.name = data.name;
            item.dataset.displayName = data.displayName;

            if (data.name === 'rubber-tube') {
                item.classList.add('clickable');
                item.addEventListener('click', (event) => {
                    event.stopPropagation();
                    if (isDrawingMode) deactivateDrawingMode();
                    else activateDrawingMode();
                });
            } else if (data.name === 'text-tool') {
                item.classList.add('clickable');
                item.addEventListener('click', (event) => {
                    event.stopPropagation();
                    if (isTextMode) deactivateTextMode();
                    else activateTextMode();
                });
            } else if (data.type === 'kigu') {
                item.draggable = true;
                item.addEventListener('dragstart', handleDragStart);
            } else {
                item.classList.add('clickable');
                item.addEventListener('click', onChemicalClick);
            }

            const img = document.createElement('img');
            img.src = data.icon;
            item.appendChild(img);

            const span = document.createElement('span');
            span.textContent = data.displayName;
            item.appendChild(span);

            list.appendChild(item);
        }

        const allKigu = Object.keys(kiguNameMap);
        const drawingTools = ['rubber-tube', 'text-tool'];
        const containers = allKigu.filter(name => containerNames.includes(name));
        const heatingItems = ['alcohol-lamp', 'stand', 'tripod', 'wire_gauze'];
        const others = allKigu.filter(name => !containerNames.includes(name) && !drawingTools.includes(name) && !heatingItems.includes(name));
        const sortedKigu = [...containers, ...heatingItems, ...others];

        sortedKigu.forEach(name => createPaletteItem(kiguList, { type: 'kigu', name, displayName: kiguNameMap[name], icon: `images/${name}.svg` }));
        drawingTools.forEach(name => createPaletteItem(byogaList, { type: 'kigu', name, displayName: kiguNameMap[name], icon: `images/${name}.svg`}));
        items.kotai.forEach(name => createPaletteItem(kotaiList, { type: 'kotai', name, displayName: name, icon: 'images/beaker.svg' }));
        items.ekitai.forEach(name => createPaletteItem(ekitaiList, { type: 'ekitai', name, displayName: name, icon: 'images/beaker.svg' }));

        // --- Main Application Logic ---
        function createTextItem(text, x, y) {
            const id = `item-${itemIdCounter++}`;
            const div = document.createElement('div');
            div.className = 'workspace-item text-item';
            div.id = id;
            div.dataset.name = text;
            div.dataset.displayName = text;
            div.dataset.type = 'text';
            div.style.left = `${x}px`;
            div.style.top = `${y}px`;
            div.style.width = 'auto'; // auto size
            div.style.height = 'auto';
            div.textContent = text;
            
            workspace.appendChild(div);
            makeDraggable(div);
            div.addEventListener('click', (e) => {
                e.stopPropagation();
                select(div);
            });
            div.addEventListener('dblclick', async (e) => {
                e.stopPropagation();
                const newText = await showTextModal();
                if (newText) {
                    div.textContent = newText;
                    div.dataset.name = newText;
                    div.dataset.displayName = newText;
                }
            });
            logAction(`テキスト「${text}」を配置しました。`);
            select(div);
        }

        async function createWorkspaceItem(data, x, y) {
            const id = `item-${itemIdCounter++}`;
            const div = document.createElement('div');
            div.className = 'workspace-item';
            div.id = id;
            div.dataset.name = data.name;
            div.dataset.displayName = data.displayName;
            div.dataset.type = data.type;
            div.style.left = `${x}px`;
            div.style.top = `${y}px`;
            
            let initialSize;
            if (data.name === 'stand') {
                initialSize = 150;
            } else {
                initialSize = 100;
            }
            div.style.width = `${initialSize}px`;
            div.style.height = `${initialSize}px`;
            div.dataset.initialWidth = initialSize;
            div.dataset.initialHeight = initialSize;

            if (data.type === 'kigu') {
                const svgText = await loadSvg(`images/${data.name}.svg`);
                const shadow = div.attachShadow({ mode: 'open' });
                shadow.innerHTML = `
                    <style>
                        :host {
                            display: inline-block;
                            width: 100%;
                            height: 100%;
                        }
                        svg {
                            width: 100%;
                            height: 100%;
                        }
                    </style>
                    ${svgText}
                `;
            }
            
            workspace.appendChild(div);
            makeDraggable(div);
            div.addEventListener('click', (e) => {
                e.stopPropagation();
                select(div);
            });
            logAction(`「${data.displayName}」を作業エリアに配置しました。`);
            select(div);
        }

        function select(item) {
            if (selectedItem) {
                selectedItem.classList.remove('selected');
            }
            if (selectedItem === item) {
                selectedItem = null;
            } else {
                selectedItem = item;
            }
            
            if (selectedItem) {
                selectedItem.classList.add('selected');
                if (selectedItem.classList.contains('workspace-item')) {
                    workspace.appendChild(selectedItem);
                }
            }
            updateControls(selectedItem);
        }

        // --- Event Handlers ---
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                document.querySelectorAll('.item-list').forEach(list => list.classList.add('hidden'));
                document.getElementById(`${tab.dataset.tab}-list`).classList.remove('hidden');
                deactivateDrawingMode();
                deactivateTextMode();
            });
        });

        function handleDragStart(e) {
            e.dataTransfer.setData('text/plain', JSON.stringify(e.currentTarget.dataset));
        }

        workspace.addEventListener('dragover', (e) => e.preventDefault());
        workspace.addEventListener('drop', (e) => {
            e.preventDefault();
            const data = JSON.parse(e.dataTransfer.getData('text/plain'));
            const workspaceRect = workspace.getBoundingClientRect();
            const x = e.clientX - workspaceRect.left - 50;
            const y = e.clientY - workspaceRect.top - 50;
            if (data.type === 'kigu' && !drawingTools.includes(data.name)) {
                createWorkspaceItem(data, x, y);
            }
        });
        workspace.addEventListener('click', (e) => {
            if (e.target === workspace) {
                select(null);
            }
        });

        // --- Draggable Logic ---
        function makeDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            element.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                if (isDrawingMode || isTextMode || e.target.closest('a, button, input')) return;
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                element.style.top = (element.offsetTop - pos2) + "px";
                element.style.left = (element.offsetLeft - pos1) + "px";
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        // --- Controls & Logging ---
        const sizeInput = document.getElementById('size-input');
        const angleInput = document.getElementById('angle-input');
        const sizeValue = document.getElementById('size-value');
        const angleValue = document.getElementById('angle-value');
        const deleteBtn = document.getElementById('delete-btn');
        const resetBtn = document.getElementById('reset-btn');
        const selectionControls = document.getElementById('selection-controls');
        const noSelection = document.getElementById('no-selection');

        function updateControls(item) {
            if (item) {
                selectionControls.classList.remove('hidden');
                noSelection.classList.add('hidden');
                
                const isEquipment = item.classList.contains('workspace-item');
                const isText = item.classList.contains('text-item');
                sizeInput.parentElement.style.display = (isEquipment && !isText) ? 'block' : 'none';
                angleInput.parentElement.style.display = isEquipment ? 'block' : 'none';

                if (isEquipment && !isText) {
                    const transform = new DOMMatrix(getComputedStyle(item).transform);
                    const angle = Math.round(Math.atan2(transform.b, transform.a) * (180 / Math.PI));
                    
                    const initialWidth = item.dataset.initialWidth;
                    const currentWidth = parseFloat(item.style.width);
                    
                    let scale = 100;
                    if (initialWidth && currentWidth && parseFloat(initialWidth) > 0) {
                        scale = Math.round((currentWidth / parseFloat(initialWidth)) * 100);
                    }

                    sizeInput.value = scale;
                    sizeValue.textContent = scale;
                    angleInput.value = angle;
                    angleValue.textContent = angle;
                }
            } else {
                selectionControls.classList.add('hidden');
                noSelection.classList.remove('hidden');
            }
        }

        function applyTransform() {
            if (!selectedItem || selectedItem.classList.contains('text-item')) return;
            const scale = sizeInput.value / 100;
            const angle = angleInput.value;
            const initialWidth = selectedItem.dataset.initialWidth;
            const initialHeight = selectedItem.dataset.initialHeight;

            if (initialWidth && initialHeight) {
                selectedItem.style.width = `${initialWidth * scale}px`;
                selectedItem.style.height = `${initialHeight * scale}px`;
            }
            selectedItem.style.transform = `rotate(${angle}deg)`;
        }

        sizeInput.addEventListener('input', () => { sizeValue.textContent = sizeInput.value; applyTransform(); });
        angleInput.addEventListener('input', () => { angleValue.textContent = angleInput.value; applyTransform(); });
        
        deleteBtn.addEventListener('click', () => {
            if (!selectedItem) return;

            if (selectedItem.classList.contains('workspace-item')) {
                logAction(`「${selectedItem.dataset.displayName}」を削除しました。`);
            } else if (selectedItem.tagName.toLowerCase() === 'path') {
                logAction('ゴム管を削除しました。');
            }
            
            selectedItem.remove();
            select(null);
        });

        resetBtn.addEventListener('click', () => {
            if (confirm('本当にすべてリセットしますか？')) {
                workspace.querySelectorAll('.workspace-item').forEach(item => item.remove());
                drawingSurface.innerHTML = '';
                logEntries.innerHTML = '';
                select(null);
                logAction('作業エリアをリセットしました。');
            }
        });

        function logAction(message) {
            const p = document.createElement('p');
            p.textContent = message;
            logEntries.appendChild(p);
            logEntries.scrollTop = logEntries.scrollHeight;
        }
        
        // --- Drawing Logic ---
        let isDrawingMode = false;
        let isTextMode = false;
        let isDrawing = false;
        let currentLine = null;
        let startPoint = null;

        function activateDrawingMode() {
            deactivateTextMode();
            isDrawingMode = true;
            workspace.classList.add('drawing-mode');
            logAction('ゴム管 描画開始');
            select(null);
        }

        function deactivateDrawingMode() {
            if (!isDrawingMode) return;
            isDrawingMode = false;
            isDrawing = false;
            if (currentLine) {
                currentLine.remove();
                currentLine = null;
            }
            startPoint = null;
            workspace.classList.remove('drawing-mode');
        }

        function activateTextMode() {
            deactivateDrawingMode();
            isTextMode = true;
            workspace.classList.add('text-mode');
            logAction('テキスト 挿入開始');
            select(null);
        }

        function deactivateTextMode() {
            if (!isTextMode) return;
            isTextMode = false;
            workspace.classList.remove('text-mode');
        }

        drawingSurface.addEventListener('mousedown', async (e) => {
            if (!isDrawingMode && !isTextMode) return;
            e.stopPropagation();

            const coords = getWorkspaceCoordinates(e);

            if (isTextMode) {
                const text = await showTextModal();
                if (text) {
                    createTextItem(text, coords.x, coords.y);
                }
                deactivateTextMode();
                return;
            }

            // Drawing mode logic
            const snapTarget = getSnapTarget(document.elementFromPoint(e.clientX, e.clientY));
            if (!isDrawing) {
                isDrawing = true;
                startPoint = snapTarget ? getElementCenter(snapTarget) : coords;
                
                currentLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                currentLine.setAttribute('class', 'drawn-line');
                currentLine.setAttribute('d', `M${startPoint.x},${startPoint.y} L${startPoint.x},${startPoint.y}`);
                drawingSurface.appendChild(currentLine);
            } else {
                // Finalize the path on the main surface to calculate its bounding box
                const endPoint = snapTarget ? getElementCenter(snapTarget) : coords;
                const midX = (startPoint.x + endPoint.x) / 2;
                const midY = (startPoint.y + endPoint.y) / 2;
                const controlX = midX - (endPoint.y - startPoint.y) * 0.25;
                const controlY = midY + (endPoint.x - startPoint.x) * 0.25;
                currentLine.setAttribute('d', `M${startPoint.x},${startPoint.y} Q${controlX},${controlY} ${endPoint.x},${endPoint.y}`);
                
                const bbox = currentLine.getBBox();
                const padding = 10; // Add padding to prevent clipping
                
                // Create a draggable div wrapper
                const id = `item-${itemIdCounter++}`;
                const div = document.createElement('div');
                div.className = 'workspace-item';
                div.id = id;
                div.dataset.name = 'ゴム管';
                div.dataset.displayName = 'ゴム管';
                div.dataset.type = 'kigu'; // Treat as equipment
                div.style.left = `${bbox.x - padding}px`;
                div.style.top = `${bbox.y - padding}px`;
                div.style.width = `${bbox.width + padding * 2}px`;
                div.style.height = `${bbox.height + padding * 2}px`;

                // Create a new SVG element inside the div
                const innerSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                innerSvg.setAttribute('width', '100%');
                innerSvg.setAttribute('height', '100%');
                
                // Clone the path and adjust its coordinates to be relative to the wrapper
                const newPath = currentLine.cloneNode();
                const newD = `M${startPoint.x - (bbox.x - padding)},${startPoint.y - (bbox.y - padding)} Q${controlX - (bbox.x - padding)},${controlY - (bbox.y - padding)} ${endPoint.x - (bbox.x - padding)},${endPoint.y - (bbox.y - padding)}`;
                newPath.setAttribute('d', newD);
                
                innerSvg.appendChild(newPath);
                div.appendChild(innerSvg);
                workspace.appendChild(div);

                // Make the new div wrapper draggable and selectable
                makeDraggable(div);
                div.addEventListener('click', (e) => {
                    e.stopPropagation();
                    select(div);
                });

                // Remove the original path from the main drawing surface
                currentLine.remove();

                logAction('ゴム管 配置完了');
                
                isDrawing = false;
                currentLine = null;
                startPoint = null; 
                deactivateDrawingMode(); // Exit drawing mode after placing one tube
            }
        });

        drawingSurface.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const coords = getWorkspaceCoordinates(e);
            
            const midX = (startPoint.x + coords.x) / 2;
            const midY = (startPoint.y + coords.y) / 2;
            const controlX = midX - (coords.y - startPoint.y) * 0.25;
            const controlY = midY + (coords.x - startPoint.x) * 0.25;
            
            currentLine.setAttribute('d', `M${startPoint.x},${startPoint.y} Q${controlX},${controlY} ${coords.x},${coords.y}`);
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (isDrawingMode) deactivateDrawingMode();
                if (isTextMode) deactivateTextMode();
                if (selectedItem) select(null);
            }
        });

        function getWorkspaceCoordinates(e) {
            const workspaceRect = workspace.getBoundingClientRect();
            return {
                x: e.clientX - workspaceRect.left,
                y: e.clientY - workspaceRect.top
            };
        }

        function getSnapTarget(element) {
            return element.closest('.workspace-item');
        }

        function getElementCenter(element) {
            const rect = element.getBoundingClientRect();
            const workspaceRect = workspace.getBoundingClientRect();
            return {
                x: rect.left - workspaceRect.left + rect.width / 2,
                y: rect.top - workspaceRect.top + rect.height / 2
            };
        }

        logAction('シミュレーションを開始しました。');
    });
    </script>
</body>
</html>